<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta charset="UTF-8"/>
  <style>@font-face{font-family:octicons-anchor;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff')}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#333;overflow:auto;font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;word-wrap:break-word}a{background:0 0}a:active,a:hover{outline:0}strong{font-weight:700}h1{margin:.67em 0}img{border:0}hr{-moz-box-sizing:content-box;box-sizing:content-box}input{color:inherit;margin:0}html input[disabled]{cursor:default}input{line-height:normal}input[type=checkbox]{-moz-box-sizing:border-box;box-sizing:border-box;padding:0}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*{-moz-box-sizing:border-box;box-sizing:border-box}input{font:13px/1.4 Helvetica,arial,freesans,clean,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"}a{color:#4183c4;text-decoration:none}a:active,a:hover{text-decoration:underline}hr{overflow:hidden;background:0 0}hr:before{display:table;content:""}hr:after{display:table;clear:both;content:""}blockquote{margin:0}ol,ul{padding:0}ol ol,ul ol{list-style-type:lower-roman}ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}dd{margin-left:0}code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace}pre{font:12px Consolas,"Liberation Mono",Menlo,Courier,monospace}.octicon{font:normal normal 16px octicons-anchor;line-height:1;display:inline-block;text-decoration:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.octicon-link:before{content:'\f05c'}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.anchor{position:absolute;top:0;left:0;display:block;padding-right:6px;padding-left:30px;margin-left:-30px}.anchor:focus{outline:0}h1,h2,h3,h4,h5,h6{position:relative;margin-top:1em;margin-bottom:16px;font-weight:700;line-height:1.4}h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{display:none;color:#000;vertical-align:middle}h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{padding-left:8px;margin-left:-30px;text-decoration:none}h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{display:inline-block}h1{padding-bottom:.3em;font-size:2.25em;line-height:1.2;border-bottom:1px solid #eee}h1 .anchor{line-height:1}h2{padding-bottom:.3em;font-size:1.75em;line-height:1.225;border-bottom:1px solid #eee}h2 .anchor{line-height:1}h3{font-size:1.5em;line-height:1.43}h3 .anchor{line-height:1.2}h4{font-size:1.25em}h4 .anchor{line-height:1.2}h5{font-size:1em}h5 .anchor{line-height:1.1}h6{font-size:1em;color:#777}h6 .anchor{line-height:1.1}blockquote,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}hr{height:4px;padding:0;margin:16px 0;background-color:#e7e7e7;border:0}ol,ul{padding-left:2em}ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}li>p{margin-top:16px}dl{padding:0}dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}dl dd{padding:0 16px;margin-bottom:16px}blockquote{padding:0 15px;color:#777;border-left:4px solid #ddd}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}table th{font-weight:700}table td,table th{padding:6px 13px;border:1px solid #ddd}table tr{background-color:#fff;border-top:1px solid #ccc}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%;-moz-box-sizing:border-box;box-sizing:border-box}code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}code:after,code:before{letter-spacing:-.2em;content:"\00a0"}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.highlight{margin-bottom:16px}.highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.highlight pre{margin-bottom:0;word-break:normal}pre{word-wrap:normal}pre code{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code:after,pre code:before{content:normal}.pl-c{color:#969896}.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv{color:#0086b3}.pl-e,.pl-en{color:#795da3}.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf{color:#333}.pl-ent{color:#63a35c}.pl-k,.pl-s,.pl-st{color:#a71d5d}.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src{color:#df5000}.pl-mo,.pl-v{color:#1d3e81}.pl-id{color:#b52a1d}.pl-ii{background-color:#b52a1d;color:#f8f8f8}.pl-sr .pl-cce{color:#63a35c;font-weight:700}.pl-ml{color:#693a17}.pl-mh,.pl-mh .pl-en,.pl-ms{color:#1d3e81;font-weight:700}.pl-mq{color:teal}.pl-mi{color:#333;font-style:italic}.pl-mb{color:#333;font-weight:700}.pl-md,.pl-mdhf{background-color:#ffecec;color:#bd2c00}.pl-mdht,.pl-mi1{background-color:#eaffea;color:#55a532}.pl-mdr{color:#795da3;font-weight:700}kbd{display:inline-block;padding:3px 5px;font:11px Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#555;vertical-align:middle;background-color:#fcfcfc;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:3px;box-shadow:inset 0 -1px 0 #bbb}.task-list-item{list-style-type:none}.task-list-item+.task-list-item{margin-top:3px}.task-list-item input{float:left;margin:.3em 0 .25em -1.6em;vertical-align:middle}:checked+.radio-label{z-index:1;position:relative;border-color:#4183c4}</style>
</head>
<body>
  <h1>
<a id="user-content-well-behaved-python-tutorial" class="anchor" href="#well-behaved-python-tutorial" aria-hidden="true"><span class="octicon octicon-link"></span></a>Well Behaved Python Tutorial</h1>

<p>Attempt to create a unit testing framework with a more fluent assertion api and set of error messages than the base python unittesting framework</p>

<h2>
<a id="user-content-set-up-a-test-case-class" class="anchor" href="#set-up-a-test-case-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Set up a test case class</h2>

<p>This will all be available in the example file demo.py. The framework is still undergoing active development. There is still too much boilerplate code that needs to be written to set up an then perform a test run.</p>

<p>First set up a test case file. We first need to import the WellBehavedPython api and TestCase classes:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> WellBehavedPython.Engine.TestCase <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">from</span> WellBehavedPython.api <span class="pl-k">import</span> <span class="pl-k">*</span></pre></div>

<p>Next, set up a the test case class, using a default constructor:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">TutorialTests</span>(<span class="pl-e">TestCase</span>):
    <span class="pl-k">pass</span></pre></div>

<p>If you need to do some setup before your classes run write a method called before, and perform the setup there. If your test case class really needs a non-default constructor argument, make sure that you call back down to the TestCase constructor; but note that this means that the auto-suite detection will not work for your test case class. Try and avoid adding any parameters to the test case constructors if at all possible.</p>

<p>We now have an empty test case class which we can run. This is now a good time to setup the running of it using a suite that can discover test methods in the class. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> WellBehavedPython.Engine.api <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">from</span> WellBehavedPython.Runners.VerboseConsoleTestRunner <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>__main__<span class="pl-pds">"</span></span>:
    <span class="pl-c"># discover tests in the local module 'TutorialTests.py'. </span>
    <span class="pl-c"># This will recurse into modules and subpackages</span>
    suite <span class="pl-k">=</span> discoverTests(<span class="pl-s"><span class="pl-pds">'</span>TutorialTests<span class="pl-pds">'</span></span>, <span class="pl-smi">suiteName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>all tests<span class="pl-pds">'</span></span>)

    runner <span class="pl-k">=</span> VerboseConsoleTestRunner(<span class="pl-smi">bufferOutput</span> <span class="pl-k">=</span> <span class="pl-c1">True</span>)
    results <span class="pl-k">=</span> runner.run(suite)    </pre></div>

<p>In the above test, we chose to run using the VerboseConsoleTestRunner. There is also a ConsoleTestRunner, which produces less verbose output.</p>

<p>We can now run the test case, and get the useful message that we got 0 failures from zero tests</p>

<div class="highlight highlight-source-shell"><pre>python3 tutorial.py
all tests...
   TutorialTests...
   TutorialTests... passed <span class="pl-k">in</span> 0.000s
all tests.......... passed <span class="pl-k">in</span> 0.000s
0 failed 0 errors 0 ignored from 0 tests</pre></div>

<p>A test method is any method within our test case class which starts with the word 'test'</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_something</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">pass</span></pre></div>

<p>We can run this test again, and see</p>

<div class="highlight highlight-source-shell"><pre>python3 tutorial.py
python3 tutorial.py
all tests...............
   TutorialTests........
      test_something ... passed <span class="pl-k">in</span> 0.001s
   TutorialTests........ passed <span class="pl-k">in</span> 0.002s
all tests............... passed <span class="pl-k">in</span> 0.003s
0 failed from 1 <span class="pl-c1">test</span></pre></div>

<p>We can set up state before tests with before and tear down state after tests with after</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">before</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.log <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>set up<span class="pl-pds">"</span></span>]

    <span class="pl-k">def</span> <span class="pl-en">test_log</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.log.append(<span class="pl-s"><span class="pl-pds">"</span>some test<span class="pl-pds">"</span></span>)

    <span class="pl-k">def</span> <span class="pl-en">after</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.log.append(<span class="pl-s"><span class="pl-pds">"</span>tear down<span class="pl-pds">"</span></span>)    </pre></div>

<h2>
<a id="user-content-simple-assertion-methods" class="anchor" href="#simple-assertion-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple Assertion methods</h2>

<p>The simplest asserts expect things to be true or false:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_true_and_false</span>(<span class="pl-smi">self</span>):        
        expect(<span class="pl-c1">True</span>).toBeTrue();
        expect(<span class="pl-c1">False</span>).toBeFalse();

        <span class="pl-c"># And have the same equivalent-to-true and</span>
        <span class="pl-c"># equivalent-to-false semantics as python does...</span>
        expect(<span class="pl-c1">1</span>).toBeTrue()
        expect([<span class="pl-c1">0</span>]).toBeTrue()
        expect(<span class="pl-c1">0</span>).toBeFalse()
        expect([]).toBeFalse()</pre></div>

<p>These assertions lead to messages of 'Expected False to be True', or
'Expected True to be False'.</p>

<p>Sometimes a little extra custom context is useful. This can be set by
starting a line with withUserMessage, rather than expect. This can be
used no matter what value is being expected against. It is
particularly useful for improving output messages when more than one
physical expectation is in the test:</p>

<div class="highlight highlight-source-python"><pre>
    <span class="pl-k">def</span> <span class="pl-en">test_add_user_message</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can add user messages to expect calls, to identify</span>
        <span class="pl-c"># what has gone wrong more clearly</span>
        withUserMessage(<span class="pl-s"><span class="pl-pds">"</span>A literal True value should be true...<span class="pl-pds">"</span></span>
                       ).expect(<span class="pl-c1">True</span>).toBeTrue()
        <span class="pl-c"># Failure message would be:</span>
        <span class="pl-c"># "A literal True values should be true: Expected True to be True"</span></pre></div>

<p>In principle the above assertions are almost all that you need to
make tests fail. However, that is not really enough. It is far more
productive to have a really descriptive error of why things fail.</p>

<p>So there is a rich set of assertions, which provide better messages:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_equality</span>(<span class="pl-smi">self</span>):
        expect(<span class="pl-c1">1</span>).toEqual(<span class="pl-c1">1</span>)
        expect(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>).toEqual(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)</pre></div>

<p>The reason for using the more specific assertions is for clarity of
failure message. Consider the following test with two otherwise
equivalent expectations:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_good_and_bad</span>(<span class="pl-smi">self</span>):
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>
        expect(actual <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>).toBeTrue() <span class="pl-c"># bad</span>
        expect(actual).toEqual(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-c"># good </span></pre></div>

<p>Compare the different output: "Expected False to be True" to
"Expected 'world' to equal 'hello'". The latter makes clear what the
wrong value that actual has 
clear exactly which condition has failed.</p>

<p>We can also test for the opposites of conditions:</p>

<div class="highlight highlight-source-python"><pre>
    <span class="pl-k">def</span> <span class="pl-en">test_negative_conditions</span>(<span class="pl-smi">self</span>):
        expect(<span class="pl-c1">1</span>).Not.toEqual(<span class="pl-c1">0</span>)
        expect(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>).Not.toEqual(<span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>)
</pre></div>

<p>If the test had world rather than hello, the error message would be
"Expected 'hello' not to equal 'world'".</p>

<h2>
<a id="user-content-expected-exceptions" class="anchor" href="#expected-exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expected Exceptions</h2>

<p>When testing failure cases it is useful to catch certain exception types.
While this can be done with a manual try-catch block, this ends up
with a lot of boilerplate code. There is a more convenient alternative,
the toRaise() method on expect objects:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_expected_exceptions_lambda</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can expect exceptions to happen, using lambda</span>
        <span class="pl-c"># expressions</span>
        expect(<span class="pl-k">lambda</span>: expect(<span class="pl-c1">True</span>).toBeFalse()).toRaise(
            <span class="pl-c1">AssertionError</span>)

    <span class="pl-k">def</span> <span class="pl-en">test_expected_exception_inner</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can use nested functions as well</span>
        <span class="pl-k">def</span> <span class="pl-en">inner</span>():
            <span class="pl-k">raise</span> <span class="pl-c1">KeyError</span>(<span class="pl-s"><span class="pl-pds">"</span>you are locked out<span class="pl-pds">"</span></span>)

        expect(inner).toRaise(<span class="pl-c1">KeyError</span>)
</pre></div>

<p>The constraint is that the function being tested must be argumentless.
Lambda expressions or inner methods are very convenient ways of doing this.
We can, of course, also use global functions:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">outer</span>():
    <span class="pl-k">raise</span> <span class="pl-c1">KeyError</span>(<span class="pl-s"><span class="pl-pds">"</span>you are locked out<span class="pl-pds">"</span></span>)

<span class="pl-k">class</span> <span class="pl-en">DemoTests</span>(<span class="pl-e">TestCase</span>):
      <span class="pl-c"># ...</span>
      <span class="pl-c"># ...</span>
      <span class="pl-c"># ...</span>

    <span class="pl-k">def</span> <span class="pl-en">test_expected_exception_inner</span>(<span class="pl-smi">self</span>):
        expect(outer).toRaise(<span class="pl-c1">KeyError</span>)
</pre></div>

<p>These methods will pass if an exception of the expected type is
thrown, and fail otherwise. But sometimes the code could have thrown the
expected exception in more than one place, or we need to check the
message being generated as well as the exception. In that case we can
use either the optional expectedMessage argument (for explicit
matching of full strings) or the expectedMessageMatches (which checks
that the message matches the given regular expression):</p>

<div class="highlight highlight-source-python"><pre>
    <span class="pl-k">def</span> <span class="pl-en">test_expected_exception_exact_message</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can match exception messages as well</span>
        expect(outer).toRaise(<span class="pl-c1">KeyError</span>, 
                              <span class="pl-smi">expectedMessage</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>you are locked out<span class="pl-pds">"</span></span>)

    <span class="pl-k">def</span> <span class="pl-en">test_expected_exception_message_matches</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can use regular expressions to match</span>
        <span class="pl-c"># parts of exception messages:</span>
        expect(outer).toRaise(<span class="pl-c1">KeyError</span>, <span class="pl-smi">expectedMessageMatches</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>lock.d<span class="pl-pds">"</span></span>)

        <span class="pl-c"># And we can use compiled regular expressions as well:</span>

        <span class="pl-k">import</span> re
        regexp <span class="pl-k">=</span> re.compile(<span class="pl-s"><span class="pl-pds">"</span>you.*out<span class="pl-pds">"</span></span>)
        expect(outer).toRaise(<span class="pl-c1">KeyError</span>, <span class="pl-smi">expectedMessageMatches</span> <span class="pl-k">=</span> regexp)
</pre></div>

<h2>
<a id="user-content-comparing-numbers" class="anchor" href="#comparing-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparing Numbers</h2>

<p>When actual is a number, code for comparing numbers is used instead of the default
comparison code. This allows numeric inequality comparison operators, &lt;, &lt;=, &gt; and &gt;=
to be used. It also allows equality to be performed in the sense of the absolute
difference being within a tolerance.</p>

<p>The inequality operators have names that should be guessable:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_numbers_can_be_compared_using_inequalities</span>(<span class="pl-smi">self</span>):
        actual <span class="pl-k">=</span> <span class="pl-c1">1.0</span>

        <span class="pl-c"># We can use the operators &gt; &gt;= &lt; and &lt;=:</span>
        expect(actual).toBeGreaterThan(<span class="pl-c1">0.0</span>)
        expect(actual).toBeGreaterThanOrEqualTo(<span class="pl-c1">1.0</span>)
        expect(actual).toBeLessThan(<span class="pl-c1">2.0</span>)
        expect(actual).toBeLessThanOrEqualTo(<span class="pl-c1">1.0</span>)</pre></div>

<p>We can also write a test that demonstrates that the equality is being
performed in the sense of having a tolerance rather than being absolute:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_equality_is_performed_within_a_tolerance</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># equality for floats is performed within a tolerance</span>
        actual <span class="pl-k">=</span> <span class="pl-c1">1.00001</span>
        expect(actual).toEqual(actual <span class="pl-k">+</span> <span class="pl-c1">1e-10</span>)</pre></div>

<p>The tolerance can be set in equality for numbers using an optional
parameter called tolerance. The tolerance type can be set using the
toleranceType parameter, which can be 'absolute' or 'relative'.</p>

<p>The defaults are a tolerance of 1e-10, a toleranceType of relative.
When the tolerance is absolute, it requries that</p>

<pre><code> |actual - expected| &lt; tolerance
</code></pre>

<p>When the tolerance type is absoulte, it requires that:</p>

<pre><code>|actual - expected|
-----------------------------   &lt; tolerance
|actual| + |expected| + 1e-20
</code></pre>

<p>The small factor of 1e-20 is a floor tolerance. This is to ensure that
when actual is exactly equal to expected, the result is 0 rather than NaN</p>

<p>We can use this to write a test with a much looser tolernace:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_equality_tolerance_can_be_configured</span>(<span class="pl-smi">self</span>):
        actual <span class="pl-k">=</span> <span class="pl-c1">1</span>
        <span class="pl-c"># we can reset the tolerance level</span>
        expect(actual).toEqual(<span class="pl-c1">1.01</span>, <span class="pl-smi">tolerance</span><span class="pl-k">=</span><span class="pl-c1">0.1</span>)
        <span class="pl-c"># We can also reset the tolerance type to be aboslute rather</span>
        <span class="pl-c"># than relative</span>
        expect(actual).toEqual(<span class="pl-c1">10</span>, <span class="pl-smi">tolerance</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>, <span class="pl-smi">toleranceType</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>absolute<span class="pl-pds">'</span></span>)</pre></div>

<h2>
<a id="user-content-comparing-containers" class="anchor" href="#comparing-containers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparing Containers</h2>

<p>Containers can be compared. Note that dictionary and strings are considered
special cases, and have their own, specialised, comparison methods.</p>

<p>The container comparison has a specialised equality comparison. This is called
in the usual manner:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_containers_can_be_compared</span>(<span class="pl-smi">self</span>):
        actual <span class="pl-k">=</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
        <span class="pl-c"># We can compare containers</span>
        expect(actual).toEqual((<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))
        expect(<span class="pl-c1">list</span>(actual)).toEqual([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])</pre></div>

<p>When this fails, the message indicates which elements differ:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected [1, 2, 3] to equal [1, 3, 4]. </span>
<span class="pl-s">First difference is at index 2: 2 != 3<span class="pl-pds">"</span></span></pre></div>

<p>This is intended to bring attention to where changes start in large
containers. </p>

<p>Containers don't have to be exactly the same type. There is some flexibility
over what constitutes 'equivalent' types. For example, tuples and lists can be
compared. This is done by definging two containers with the same contents in the
same order as equal.</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_similar_containers_can_be_compared</span>(<span class="pl-smi">self</span>):
        actual <span class="pl-k">=</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
        expect(actual).toEqual([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>])</pre></div>

<p>Furthermore, containers can be compared to other containers, using toBeASupersetOf and
toBeASubsetOf:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_set_relations_can_be_expected</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># We can also expect the actual to be a superset or</span>
        <span class="pl-c"># a subset of another container. This generalises</span>
        <span class="pl-c"># the pyhton sets, so that set comparisons can work</span>
        <span class="pl-c"># on lists and tuples:</span>
        actual <span class="pl-k">=</span> (<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>) <span class="pl-c"># a tuple</span>
        expect(actual).toBeASupersetOf([<span class="pl-c1">2</span>]) 
        expect(actual).toBeASubsetOf([<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>])        </pre></div>

<h2>
<a id="user-content-dictionary-comparisons" class="anchor" href="#dictionary-comparisons" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dictionary comparisons</h2>

<p>Dictionaries are slightly richer than standard containers, and having their
own comparison assertions allow more descriptive errors to be made.</p>

<p>There is a dictionary-specific equality method.</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_dictionary_equality</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Dictionaries can be compared. The failure message</span>
        <span class="pl-c"># then knows it is a dictionary being compared and</span>
        <span class="pl-c"># adds some more useful information to help understand</span>
        <span class="pl-c"># the cause of the failure.</span>
        actual <span class="pl-k">=</span> {<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> : <span class="pl-c1">1</span>,
                  <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> : <span class="pl-c1">2</span> }

        expect(actual).toEqual({<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>:<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>:<span class="pl-c1">2</span>})</pre></div>

<p>If the dictionaries to not match, the error message looks like these:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected {} to be a dictionary containing 1 item<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected {'b': 2, 'a': 1} to equal {'z': 26, 'a': 1}</span>
<span class="pl-s">First missing key is 'b'<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected {'b': 2, 'a': 1} to equal {'b': 26, 'a': 1}</span>
<span class="pl-s">First difference at key 'b': Expected 2 to equal 26<span class="pl-pds">"</span></span></pre></div>

<p>Dictionaries can also be expected to contain specific keys:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_dictionary_contains_key</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Whether a dictionary contains a key is a useful test,</span>
        <span class="pl-c"># and having a method for it can give a more</span>
        <span class="pl-c"># enlightening error message than using a container</span>
        <span class="pl-c"># comparison on the keys view:</span>
        actual <span class="pl-k">=</span> {<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> : <span class="pl-c1">1</span>, 
                  <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> : <span class="pl-c1">2</span>}

        expect(actual).toContainKey(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
        expect(actual).Not.toContainKey(<span class="pl-c1">1</span>)</pre></div>

<p>The messages received from keys missing are more helpful than performing
container expectations on the keys view:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected {'b': 2, 'a': 1} to contain key 'z'<span class="pl-pds">"</span></span></pre></div>

<p>Of course, dictionaries also contain values, so there is also a toContainValue:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_dictionary_contains_value</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Whether a dictionary contains a value is also a useful</span>
        <span class="pl-c"># test, and gives a more enlightening message than using</span>
        <span class="pl-c"># a conainer comparison on the values view.</span>
        actual <span class="pl-k">=</span> {<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> : <span class="pl-c1">1</span>, 
                  <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> : <span class="pl-c1">2</span>}

        expect(actual).toContainValue(<span class="pl-c1">1</span>)
        expect(actual).Not.toContainValue(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)</pre></div>

<p>The messages received from values missing are more helpful than performing
container expectations on the values view:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected {'b': 2, 'a': 1} to contain value 26<span class="pl-pds">"</span></span></pre></div>

<h2>
<a id="user-content-comparing-strings" class="anchor" href="#comparing-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparing strings</h2>

<p>Strings are compared using a specialised class, which gives richer messages on
string equality comparisons, and adds methods to match substrings at the start,
end end inside the string. It also provides methods to match against regular expression
patterns.</p>

<p>Both strings and multiline strings can be compared:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_string_equal</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Strings can be compared for equality.</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>
        expect(actual).toEqual(<span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>)

    <span class="pl-k">def</span> <span class="pl-en">test_multiline_string_equal</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Multi-line strings can be compared. When they are</span>
        <span class="pl-c"># any differences are reported using the pyhton</span>
        <span class="pl-c"># difflib utility.</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span>asdf</span>
<span class="pl-s">lqwerty</span>
<span class="pl-s">poiu</span>
<span class="pl-s">zzzz<span class="pl-pds">"""</span></span>
        expect(actual).toEqual(<span class="pl-s"><span class="pl-pds">"""</span>asdf</span>
<span class="pl-s">lqwerty</span>
<span class="pl-s">poiu</span>
<span class="pl-s">zzzz<span class="pl-pds">"""</span></span>)</pre></div>

<p>When the comparison fails, a diff between the two strings is generated
and added to the exception message:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected 'asdf</span>
<span class="pl-s">lqwerty</span>
<span class="pl-s">poiu</span>
<span class="pl-s">zzzz' to equal 'asdfZ</span>
<span class="pl-s">lqwerty</span>
<span class="pl-s">XXXX</span>
<span class="pl-s">zzzz'</span>
<span class="pl-s">Difference is:</span>
<span class="pl-s">- asdf</span>
<span class="pl-s">+ asdfZ</span>
<span class="pl-s">?     +</span>
<span class="pl-s"></span>
<span class="pl-s">  lqwerty</span>
<span class="pl-s">- poiu</span>
<span class="pl-s">+ XXXX</span>
<span class="pl-s">  zzzz<span class="pl-pds">"</span></span></pre></div>

<p>Strings starts and ends can also be compared:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_string_starts_with</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Strings can be expected to start with a certain substring</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>
        expect(actual).toStartWith(<span class="pl-s"><span class="pl-pds">"</span>as<span class="pl-pds">"</span></span>)

    <span class="pl-k">def</span> <span class="pl-en">test_string_ends_with</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Strings can be expected to end with a certain substring</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>
        expect(actual).toEndWith(<span class="pl-s"><span class="pl-pds">"</span>df<span class="pl-pds">"</span></span>)</pre></div>

<p>The messages then generated look like:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected 'asdf' to be a string starting with 'df'</span>
<span class="pl-s">Difference is:</span>
<span class="pl-s">- asdf</span>
<span class="pl-s">+ df<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected 'asdf' to be a string ending with 'as'</span>
<span class="pl-s">Difference is:</span>
<span class="pl-s">- asdf</span>
<span class="pl-s">+ as<span class="pl-pds">"</span></span></pre></div>

<p>String contents can be compared using toContain:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_string_to_contain</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Strings can be expected to contain substrings</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>
        expect(actual).toContain(<span class="pl-s"><span class="pl-pds">"</span>sd<span class="pl-pds">"</span></span>)</pre></div>

<p>The message on error looks like</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected 'asdf' to be a string containing 'ds'<span class="pl-pds">"</span></span></pre></div>

<p>And strings can be expected to match against regular expression patterns:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_string_toMatch</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># String can be expected to match string and compiled</span>
        <span class="pl-c"># regular expression patterns</span>
        actual <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>asdf<span class="pl-pds">"</span></span>

        pattern <span class="pl-k">=</span> re.compile(<span class="pl-s"><span class="pl-pds">"</span>.sd.<span class="pl-pds">"</span></span>)
        expect(actual).toMatch(<span class="pl-s"><span class="pl-pds">"</span>a..f<span class="pl-pds">"</span></span>)
        expect(actual).toMatch(pattern)                </pre></div>

<p>When these assertions fail, it leads to messages that look like:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected 'asdf' to be a string matching regular expression pattern '[a-z]+0'<span class="pl-pds">"</span></span></pre></div>

<h2>
<a id="user-content-checking-if-and-how-class-methods-have-been-called" class="anchor" href="#checking-if-and-how-class-methods-have-been-called" aria-hidden="true"><span class="octicon octicon-link"></span></a>Checking if and how class methods have been called</h2>

<p>We pass a method to be spied on to the spyOn method to create a method spy:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c1">object</span> <span class="pl-k">=</span> SomeClass()
spyOn(<span class="pl-c1">object</span>.method)</pre></div>

<p>This replaces object.method with a method which accepts the same calling signature,
and records the arguments each time the method was called. </p>

<p>Alternatively, if there are a lot of methods in the instance, we might spy on the
entire instance:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c1">object</span> <span class="pl-k">=</span> SomeClass()
spyOn(<span class="pl-c1">object</span>) <span class="pl-c"># equivalent to calling spyOn(objectd.method) for each public method</span></pre></div>

<p>We can then expect object.method to have been called. First, we set up some
sample methods:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">DemoTests</span>:
    <span class="pl-c"># ...</span>

    <span class="pl-k">def</span> <span class="pl-en">targetMethod</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.wasCalled <span class="pl-k">=</span> <span class="pl-c1">True</span>

    <span class="pl-k">def</span> <span class="pl-en">targetMethodWithParameters</span>(<span class="pl-smi">self</span>, <span class="pl-smi">a</span>, <span class="pl-smi">b</span>, <span class="pl-smi">c</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-smi">d</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>):
        <span class="pl-v">self</span>.wasCalled <span class="pl-k">=</span> <span class="pl-c1">True</span></pre></div>

<p>Then we can create tests which spy on these methods. We can expect the methods
to have been called at all, an exact number of times, at least N times or at
most N times.</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_can_create_a_method_spy</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        spyOn(<span class="pl-v">self</span>.targetMethod)

        <span class="pl-c"># When</span>
        <span class="pl-v">self</span>.wasCalled <span class="pl-k">=</span> <span class="pl-c1">False</span>
        <span class="pl-v">self</span>.targetMethod()

        <span class="pl-c"># Then</span>
        expect(<span class="pl-v">self</span>.wasCalled).toBeFalse()
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalled()
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalledExactly(<span class="pl-c1">1</span>).time()
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalledAtLeast(<span class="pl-c1">1</span>).time()
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalledAtMost(<span class="pl-c1">3</span>).times()</pre></div>

<p>This leads to error messages of the form</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-s"><span class="pl-pds">"</span>Expected &lt;targetMethod&gt; to have been called<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected &lt;targetMethod&gt; to have been called exactly 1 time, but it was never called.<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected &lt;targetMethod&gt; to have been called at least 1 time, but it was never called.<span class="pl-pds">"</span></span>
<span class="pl-s"><span class="pl-pds">"</span>Expected &lt;targetMethod&gt; to have been called at most 3 times, but it was called 4 times.<span class="pl-pds">"</span></span></pre></div>

<p>Sometimes, it is useful to check whether a method has been called with certain arguments, using
toHaveBeenCalledWith. We can also indicate we only care about a single invocation by usining
forCallNumber(). The numbers here are numbers, not indices - so to check for the first call, use
1, not 0.</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_spies_can_expect_on_arguments_used</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        spyOn(<span class="pl-v">self</span>.targetMethodWithParameters)

        <span class="pl-c"># When</span>
        <span class="pl-v">self</span>.targetMethodWithParameters(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-smi">d</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>four<span class="pl-pds">'</span></span>)
        <span class="pl-v">self</span>.targetMethodWithParameters([<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], <span class="pl-c1">3</span>)

        <span class="pl-c"># Then</span>
        expect(<span class="pl-v">self</span>.targetMethodWithParameters).toHaveBeenCalledWith(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-smi">d</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>four<span class="pl-pds">'</span></span>)
        expect(<span class="pl-v">self</span>.targetMethodWithParameters).toHaveBeenCalledWith([<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], <span class="pl-c1">3</span>)
        expect(<span class="pl-v">self</span>.targetMethodWithParameters).forCallNumber(<span class="pl-c1">1</span>).Not.toHaveBeenCalledWith([<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>], <span class="pl-c1">3</span>)</pre></div>

<p>It is possible to configure a spy to return a specific value:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_spying_and_overriding_return_value</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        spyOn(<span class="pl-v">self</span>.targetMethod).andReturn(<span class="pl-c1">5</span>)

        <span class="pl-c"># When</span>
        value <span class="pl-k">=</span> <span class="pl-v">self</span>.targetMethod()

        <span class="pl-c"># Then</span>
        expect(value).toEqual(<span class="pl-c1">5</span>)</pre></div>

<p>Or to raise an exception when called. This is useful for testing exception handling code:</p>

<div class="highlight highlight-source-python"><pre>
    <span class="pl-k">def</span> <span class="pl-en">test_creating_a_test_saboteur</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        spyOn(<span class="pl-v">self</span>.targetMethod).andRaise(<span class="pl-c1">KeyError</span>)

        <span class="pl-c"># Then</span>
        expect(<span class="pl-v">self</span>.targetMethod).toRaise(<span class="pl-c1">KeyError</span>)
</pre></div>

<p>We can also tell the spy to call through to the original method as well:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_creaating_a_spy_which_calls_through</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        spyOn(<span class="pl-v">self</span>.targetMethod).andCallThrough()

        <span class="pl-c"># When</span>
        <span class="pl-v">self</span>.wasCalled <span class="pl-k">=</span> <span class="pl-c1">False</span>
        <span class="pl-v">self</span>.targetMethod()

        <span class="pl-c"># Then</span>
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalled()
        expect(<span class="pl-v">self</span>.wasCalled).toBeTrue()</pre></div>

<p>If any extra behaviour is needed, it is possible to configure the spy to also call
through to any callable object:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">test_that_a_spy_with_arbitrary_beahviour_can_be_created</span>(<span class="pl-smi">self</span>):
        <span class="pl-c"># Where</span>
        <span class="pl-v">self</span>.manualWasCalled <span class="pl-k">=</span> <span class="pl-c1">False</span>
        <span class="pl-k">def</span> <span class="pl-en">inner_method</span>():
            <span class="pl-v">self</span>.manualWasCalled <span class="pl-k">=</span> <span class="pl-c1">True</span>

        spyOn(<span class="pl-v">self</span>.targetMethod).andCall(inner_method)

        <span class="pl-c"># When</span>
        <span class="pl-v">self</span>.targetMethod()

        <span class="pl-c"># Then</span>
        expect(<span class="pl-v">self</span>.targetMethod).toHaveBeenCalled()
        expect(<span class="pl-v">self</span>.manualWasCalled).toBeTrue()</pre></div>

<h2>
<a id="user-content-manually-configurig-a-spy" class="anchor" href="#manually-configurig-a-spy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manually configurig a spy</h2>

<p>Sometimes, we want to create an object for a system under test to use, without directly creating
its collabortors. This can happen for a variety of reasons:</p>

<ul>
<li>The collaborator hasn't been created yet</li>
<li>The collaborator is time consuming to construct</li>
<li>The collaborator is complex to construct</li>
</ul>

<p>In these cases, we can create an instance of the ObjectSpy class:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> WellBehavedPython.Fakes.ObjectSpy

spy <span class="pl-k">=</span> ObjectSpy(<span class="pl-smi">methods</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>aMethod<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>anotherMethod<span class="pl-pds">'</span></span>}, properties <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>something<span class="pl-pds">'</span></span>])</pre></div>

</body></html>
